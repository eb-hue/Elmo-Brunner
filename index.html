<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Elmo Games â€“ Kostenlose Browser-Spiele</title>
  <style>
    body {
      background: #0d1117;
      color: #c9d1d9;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      text-align: center;
    }
    h1 { color: #58a6ff; margin-bottom: 10px; }
    p.intro { margin-bottom: 30px; }
    .game {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 10px;
      margin: 30px auto;
      padding: 20px;
      max-width: 900px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    }
    .game h2 { margin-top: 0; color: #79c0ff; }
    iframe {
      width: 100%;
      height: 600px;          /* erhÃ¶ht â€“ besser fÃ¼r die meisten Spiele */
      border: none;
      border-radius: 10px;
      background: #000;       /* falls iframe leer ist, sieht es besser aus */
    }
    .note {
      color: #8b949e;
      font-size: 0.9em;
      margin-top: 8px;
    }
  </style>
</head>
<body>

  <h1>Elmo Games ðŸŽ®</h1>
  <p class="intro">Kostenlose Browser-Spiele â€“ direkt im Browser spielen!</p>

  <div class="game">
    <h2>Among Us Singleplayer (Fan-Game)</h2>
    <iframe src="https://sackgta.itch.io/among-us-single-player-fan-game/embed" allowfullscreen></iframe>
    <p class="note">Gegen Bots Ã¼ben â€“ funktioniert zuverlÃ¤ssig im Browser</p>
  </div>

  <div class="game">
    <h2>Bubble Tower 3D</h2>
    <iframe src="https://play.famobi.com/bubble-tower-3d" allowfullscreen></iframe>
    <p class="note">Entspannendes Puzzle mit Blasen â€“ von Famobi</p>
  </div>

  <!-- Slither.io als eigenstÃ¤ndiges vollwertiges Spiel (nicht in iframe) -->
  <div class="game" style="padding:0; overflow:hidden; position:relative;">
    <h2>Slither.io Mini (Singleplayer)</h2>
    <div id="ui" style="position:absolute; top:10px; left:10px; color:white; font-family:Arial; z-index:10; background:rgba(0,0,0,0.4); padding:8px 12px; border-radius:6px;">
      Score: <span id="score">0</span>
    </div>
    <canvas id="c" style="display:block; width:100%; height:600px;"></canvas>
  </div>

  <script>
    // === Dein Slither.io Mini Code (unverÃ¤ndert, funktioniert jetzt im div) ===
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');

    let WIDTH, HEIGHT;
    function resize() {
      WIDTH = canvas.width = canvas.clientWidth;
      HEIGHT = canvas.height = canvas.clientHeight;   // clientHeight statt innerHeight â†’ passt besser ins div
    }
    window.addEventListener('resize', resize);
    resize();   // initial

    let snake = [];
    let angle = 0;
    let speed = 2.2;
    let boost = false;
    let score = 0;

    for (let i = 0; i < 20; i++) {
      snake.push({x: WIDTH/2 - i*4, y: HEIGHT/2});
    }

    let foods = [];
    function spawnFood() {
      foods.push({
        x: Math.random() * WIDTH,
        y: Math.random() * HEIGHT,
        color: `hsl(${Math.random()*360}, 80%, 60%)`,
        size: 8 + Math.random()*6
      });
    }
    for (let i = 0; i < 80; i++) spawnFood();

    let mouse = {x: WIDTH/2, y: HEIGHT/2};
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.touches[0].clientX - rect.left;
      mouse.y = e.touches[0].clientY - rect.top;
    });

    window.addEventListener('keydown', e => { if (e.code === 'Space') boost = true; });
    window.addEventListener('keyup',   e => { if (e.code === 'Space') boost = false; });

    function update() {
      const dx = mouse.x - snake[0].x;
      const dy = mouse.y - snake[0].y;
      angle = Math.atan2(dy, dx);

      let currentSpeed = boost ? speed * 1.8 : speed;
      const head = {
        x: snake[0].x + Math.cos(angle) * currentSpeed,
        y: snake[0].y + Math.sin(angle) * currentSpeed
      };

      if (snake.length > 30) {
        for (let i = 10; i < snake.length; i += 8) {
          const dist = Math.hypot(head.x - snake[i].x, head.y - snake[i].y);
          if (dist < 15) {
            alert("Game Over! Score: " + score);
            snake = [{x: WIDTH/2, y: HEIGHT/2}];
            score = 0;
            scoreEl.textContent = 0;
            foods = [];
            for (let i = 0; i < 80; i++) spawnFood();
            return;
          }
        }
      }

      snake.unshift(head);

      for (let i = foods.length - 1; i >= 0; i--) {
        const f = foods[i];
        const dist = Math.hypot(head.x - f.x, head.y - f.y);
        if (dist < f.size + 12) {
          foods.splice(i, 1);
          score += 1;
          scoreEl.textContent = score;
          snake.push({...snake[snake.length-1]});
          spawnFood();
        }
      }

      if (!boost && snake.length > 40 + score) {
        snake.pop();
      }
    }

    function draw() {
      ctx.fillStyle = '#0a0f1a';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      ctx.strokeStyle = 'rgba(100,120,255,0.08)';
      ctx.lineWidth = 1;
      for (let x = 0; x < WIDTH; x += 40) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, HEIGHT); ctx.stroke();
      }
      for (let y = 0; y < HEIGHT; y += 40