<div class="game slither-container" style="position: relative; overflow: hidden; border-radius: 10px; background: #000; height: 500px; max-height: 70vh;">
  <h2>Slither.io Mini (Singleplayer)</h2>
  <div id="slither-ui" style="position: absolute; top: 10px; left: 10px; color: white; z-index: 10; font-size: 1.2em; font-weight: bold;">
    Score: <span id="score">0</span> | Länge: <span id="length">20</span>
  </div>
  <canvas id="slither-canvas" style="width:100%; height:100%; touch-action: none; cursor: none;"></canvas>
  <p style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); color: #aaa; font-size: 0.85em; margin: 0; pointer-events: none; z-index: 5; text-align: center;">
    Finger/Maus = lenken | Doppeltippen/Leertaste = Boost (Schwanz schrumpft!)
  </p>
</div>

<script>
// ULTRA-REALISTISCHE SLITHER.IO NACHBAUUNG – mit Gegnern + echter Physik

const canvas = document.getElementById('slither-canvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const lengthEl = document.getElementById('length');

let width, height;
function resize() {
  const rect = canvas.getBoundingClientRect();
  width = canvas.width = rect.width;
  height = canvas.height = rect.height;
}
window.addEventListener('resize', resize);
resize();

// === SPIELER ===
let player = {
  segments: [],
  angle: 0,
  speed: 2.8,
  boost: false,
  boostTimer: 0,
  score: 0
};

// === GEGNER ===
let enemies = [];
class Enemy {
  constructor() {
    this.segments = [];
    this.angle = Math.random() * Math.PI * 2;
    this.speed = 1.8 + Math.random() * 0.8;
    this.color = `hsl(${Math.random()*360}, 80%, 55%)`;
    this.size = 18 + Math.random() * 8;
    this.targetX = Math.random() * width;
    this.targetY = Math.random() * height;
    this.alive = true;
    
    // Startposition
    for (let i = 0; i < 15 + Math.random()*10; i++) {
      this.segments.push({x: width/2 + (Math.random()-0.5)*100, y: height/2 + (Math.random()-0.5)*100});
    }
  }
  
  update() {
    if (!this.alive || this.segments.length < 3) return;
    
    // Neues Ziel (ändert sich langsam)
    if (Math.random() < 0.02) {
      this.targetX = Math.random() * width;
      this.targetY = Math.random() * height;
    }
    
    const dx = this.targetX - this.segments[0].x;
    const dy = this.targetY - this.segments[0].y;
    this.angle = Math.atan2(dy, dx);
    
    // Bewegung mit echter Schwanz-Physik
    const head = {
      x: this.segments[0].x + Math.cos(this.angle) * this.speed,
      y: this.segments[0].y + Math.sin(this.angle) * this.speed
    };
    
    // Wrap around
    head.x = (head.x + width) % width;
    head.y = (head.y + height) % height;
    
    this.segments.unshift(head);
    
    // Leichtes Schrumpfen
    if (Math.random() < 0.1) {
      this.segments.pop();
    }
  }
  
  draw() {
    if (!this.alive || this.segments.length < 2) return;
    
    ctx.lineWidth = this.size;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    // Farbverlauf
    for (let i = 0; i < this.segments.length - 1; i++) {
      const t = i / (this.segments.length - 1);
      ctx.strokeStyle = `hsl(${this.color.hue + t*60}, ${80 - t*10}%, ${55 - t*5}%)`;
      ctx.beginPath();
      ctx.moveTo(this.segments[i].x, this.segments[i].y);
      ctx.lineTo(this.segments[i+1].x, this.segments[i+1].y);
      ctx.stroke();
    }
    
    // Augen
    const head = this.segments[0];
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(head.x + Math.cos(this.angle)*8, head.y + Math.sin(this.angle)*8 - 5, 3, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(head.x + Math.cos(this.angle)*8, head.y + Math.sin(this.angle)*8 + 5, 3, 0, Math.PI*2);
    ctx.fill();
  }
}

// === ESSEN ===
let foods = [];
function spawnFood() {
  foods.push({
    x: Math.random() * width,
    y: Math.random() * height,
    size: 5 + Math.random() * 6,
    color: `hsl(${Math.random()*360}, 85%, 65%)`,
    glow: Math.random() * 0.5 + 0.5
  });
}

// === INITIALISIERUNG ===
function init() {
  // Spieler zurücksetzen
  player.segments = [];
  for (let i = 0; i < 25; i++) {
    player.segments.push({x: width/2 - i*4, y: height/2});
  }
  player.score = 0;
  player.boost = false;
  player.boostTimer = 0;
  scoreEl.textContent = '0';
  lengthEl.textContent = '25';
  
  // Foods
  foods = [];
  for (let i = 0; i < 150; i++) spawnFood();
  
  // 8 Gegner spawnen
  enemies = [];
  for (let i = 0; i < 8; i++) {
    enemies.push(new Enemy());
  }
}
init();

// === INPUT ===
let pointerX = width / 2;
let pointerY = height / 2;

function updatePointer(e) {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const touch = e.touches ? e.touches[0] : e;
  pointerX = touch.clientX - rect.left;
  pointerY = touch.clientY - rect.top;
}

canvas.addEventListener('mousemove', updatePointer);
canvas.addEventListener('touchmove', updatePointer, {passive: false});
canvas.addEventListener('touchstart', updatePointer, {passive: false});

// Boost
let lastTap = 0;
canvas.addEventListener('touchend', e => {
  const now = Date.now();
  if (now - lastTap < 250) {
    player.boost = true;
  }
  lastTap = now;
});

window.addEventListener('keydown', e => {
  if (e.code === 'Space') {
    e.preventDefault();
    player.boost = true;
  }
});
window.addEventListener('keyup', e => {
  if (e.code === 'Space') player.boost = false;
});

// === UPDATE ===
function update() {
  // Spieler-Update
  const dx = pointerX - player.segments[0].x;
  const dy = pointerY - player.segments[0].y;
  player.angle = Math.atan2(dy, dx);
  
  let speed = player.speed;
  if (player.boost) {
    speed *= 1.8;
    player.boostTimer++;
  }
  
  const head = {
    x: player.segments[0].x + Math.cos(player.angle) * speed,
    y: player.segments[0].y + Math.sin(player.angle) * speed
  };
  
  // WRAP AROUND (wie echtes Slither)
  head.x = (head.x + width) % width;
  head.y = (head.y + height) % height;
  
  player.segments.unshift(head);
  
  // Boost = Schrumpfen
  if (player.boost) {
    if (player.segments.length > 10) {
      player.segments.pop();
    }
  }
  
  // Essen sammeln
  for (let i = foods.length - 1; i >= 0; i--) {
    const f = foods[i];
    const dist = Math.hypot(head.x - f.x, head.y - f.y);
    if (dist < f.size + 16) {
      foods.splice(i, 1);
      player.score += 1;
      scoreEl.textContent = player.score;
      lengthEl.textContent = player.segments.length;
      // Wachsen
      player.segments.push({...player.segments[player.segments.length-1]});
      spawnFood();
    }
  }
  
  // Gegner updaten
  enemies.forEach(enemy => {
    enemy.update();
    
    // Kollision mit Gegner (Game Over)
    if (player.segments.length > 30) {
      for (let j = 10; j < enemy.segments.length; j++) {
        const dist = Math.hypot(head.x - enemy.segments[j].x, head.y - enemy.segments[j].y);
        if (dist < 22) {
          alert(`Game Over! Score: ${player.score} | Länge: ${player.segments.length}`);
          init();
          return;
        }
      }
    }
    
    // Gegner gegessen? (Kopf berührt)
    const enemyHeadDist = Math.hypot(head.x - enemy.segments[0].x, head.y - enemy.segments[0].y);
    if (enemyHeadDist < 25 && player.segments.length > enemy.segments.length * 1.2) {
      enemy.alive = false;
      // Massiv wachsen!
      for (let k = 0; k < enemy.segments.length * 2; k++) {
        player.segments.push({...player.segments[player.segments.length-1]});
      }
      player.score += enemy.segments.length * 3;
      scoreEl.textContent = player.score;
      lengthEl.textContent = player.segments.length;
    }
  });
  
  // tote Gegner entfernen + neue spawnen
  enemies = enemies.filter(e => e.alive);
  if (enemies.length < 8) {
    enemies.push(new Enemy());
  }
  
  // Natürliches Schrumpfen
  if (!player.boost && player.segments.length > 25 + player.score * 0.1) {
    player.segments.pop();
  }
}

// === RENDER ===
function draw() {
  // Dunkler Hintergrund mit Sternen
  ctx.fillStyle = '#0a0f1a';
  ctx.fillRect(0, 0, width, height);
  
  // Sternen-Hintergrund
  ctx.fillStyle = 'rgba(255,255,255,0.03)';
  for (let i = 0; i < 80; i++) {
    const x = (i * 137.5) % width;
    const y = (i * 239.1) % height;
    ctx.beginPath();
    ctx.arc(x, y, 1.5, 0, Math.PI*2);
    ctx.fill();
  }
  
  // Foods mit Glow
  foods.forEach(f => {
    const gradient = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, f.size + 3);
    gradient.addColorStop(0, f.color);
    gradient.addColorStop(0.7, f.color);
    gradient.addColorStop(1, 'transparent');
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(f.x, f.y, f.size + 3, 0, Math.PI*2);
    ctx.fill();
  });
  
  // Gegner zeichnen
  enemies.forEach(enemy => enemy.draw());
  
  // SPIELER zeichnen (dicker + Glow)
  if (player.segments.length > 1) {
    ctx.lineWidth = 28;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.shadowBlur = 15;
    ctx.shadowColor = 'cyan';
    
    // Farbverlauf (Blau -> Cyan)
    for (let i = 0; i < player.segments.length - 1; i++) {
      const t = i / (player.segments.length - 1);
      ctx.strokeStyle = `hsl(${180 + t*60}, 90%, ${55 + t*10}%)`;
      ctx.beginPath();
      ctx.moveTo(player.segments[i].x, player.segments[i].y);
      ctx.lineTo(player.segments[i+1].x, player.segments[i+1].y);
      ctx.stroke();
    }
    ctx.shadowBlur = 0;
    
    // Augen (größer + Glow)
    const head = player.segments[0];
    const eyeSize = 6;
    ctx.shadowBlur = 10;
    ctx.shadowColor = 'white';
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(head.x + Math.cos(player.angle)*12, head.y + Math.sin(player.angle)*12 - 7, eyeSize, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(head.x + Math.cos(player.angle)*12, head.y + Math.sin(player.angle)*12 + 7, eyeSize, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

// === GAME LOOP ===
function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>