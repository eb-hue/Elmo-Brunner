<div class="game slither-container" style="position: relative; overflow: hidden; border-radius: 10px; background: #000; height: 500px; max-height: 70vh;">
  <h2>Slither.io Mini (Singleplayer)</h2>
  <div id="slither-ui" style="position: absolute; top: 10px; left: 10px; color: white; z-index: 10; font-size: 1.2em;">
    Score: <span id="score">0</span>
  </div>
  <canvas id="slither-canvas" style="width:100%; height:100%; touch-action: none;"></canvas>
  <p style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); color: #aaa; font-size: 0.9em; margin: 0; pointer-events: none; z-index: 5;">
    Finger bewegen = lenken | Doppeltippen = Boost
  </p>
</div>

<script>
// Sehr einfache Slither-Version – optimiert für iPad/Safari

const canvas = document.getElementById('slither-canvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');

let width, height;
function resize() {
  const rect = canvas.getBoundingClientRect();
  width = canvas.width = rect.width;
  height = canvas.height = rect.height;
}
window.addEventListener('resize', resize);
resize();

let snake = [];
let foods = [];
let score = 0;
let angle = 0;
let boost = false;
let pointerX = width / 2;
let pointerY = height / 2;

function init() {
  snake = [];
  for (let i = 0; i < 20; i++) {
    snake.push({x: width/2, y: height/2});
  }
  foods = [];
  for (let i = 0; i < 60; i++) spawnFood();
  score = 0;
  scoreEl.textContent = '0';
}
init();

function spawnFood() {
  foods.push({
    x: Math.random() * width,
    y: Math.random() * height,
    size: 5 + Math.random() * 7,
    color: `hsl(${Math.random()*360}, 90%, 60%)`
  });
}

// Touch & Maus – einheitlich
function updatePointer(e) {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const touch = e.touches ? e.touches[0] : e;
  pointerX = touch.clientX - rect.left;
  pointerY = touch.clientY - rect.top;
}

canvas.addEventListener('mousemove', updatePointer);
canvas.addEventListener('touchmove', updatePointer, {passive: false});
canvas.addEventListener('touchstart', updatePointer, {passive: false});

// Boost mit Doppeltipp (Touch) oder Leertaste
let lastTap = 0;
canvas.addEventListener('touchend', e => {
  const now = Date.now();
  if (now - lastTap < 280) {
    boost = !boost;
  }
  lastTap = now;
});

window.addEventListener('keydown', e => {
  if (e.code === 'Space') {
    e.preventDefault();
    boost = true;
  }
});
window.addEventListener('keyup', e => {
  if (e.code === 'Space') boost = false;
});

function update() {
  if (snake.length < 2) return;

  // Richtung zum Pointer
  const dx = pointerX - snake[0].x;
  const dy = pointerY - snake[0].y;
  angle = Math.atan2(dy, dx);

  const speed = boost ? 4.2 : 2.4;
  const head = {
    x: snake[0].x + Math.cos(angle) * speed,
    y: snake[0].y + Math.sin(angle) * speed
  };

  // Wrap around (kein Game Over am Rand)
  if (head.x < 0) head.x = width;
  if (head.x > width) head.x = 0;
  if (head.y < 0) head.y = height;
  if (head.y > height) head.y = 0;

  snake.unshift(head);

  // Essen essen
  for (let i = foods.length - 1; i >= 0; i--) {
    const f = foods[i];
    const dist = Math.hypot(head.x - f.x, head.y - f.y);
    if (dist < f.size + 16) {
      foods.splice(i, 1);
      score++;
      scoreEl.textContent = score;
      snake.push({...snake[snake.length-1]}); // wachsen
      spawnFood();
    }
  }

  // Selbstkollision – erst ab längerer Schlange
  if (snake.length > 35) {
    for (let i = 15; i < snake.length; i += 8) {
      if (Math.hypot(head.x - snake[i].x, head.y - snake[i].y) < 20) {
        alert("Game Over! Score: " + score);
        init();
        return;
      }
    }
  }
}

function draw() {
  ctx.fillStyle = '#0a0f1a';
  ctx.fillRect(0, 0, width, height);

  // Essen
  foods.forEach(f => {
    ctx.fillStyle = f.color;
    ctx.beginPath();
    ctx.arc(f.x, f.y, f.size, 0, Math.PI*2);
    ctx.fill();
  });

  // Schlange – einfacher Farbverlauf
  if (snake.length < 2) return;
  ctx.lineWidth = 24;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  for (let i = 0; i < snake.length - 1; i++) {
    const t = i / (snake.length - 1);
    ctx.strokeStyle = `hsl(${t * 180 + 180}, 90%, 55%)`;
    ctx.beginPath();
    ctx.moveTo(snake[i].x, snake[i].y);
    ctx.lineTo(snake[i+1].x, snake[i+1].y);
    ctx.stroke();
  }

  // Augen
  const head = snake[0];
  ctx.fillStyle = 'white';
  ctx.beginPath();
  ctx.arc(head.x + Math.cos(angle)*10, head.y + Math.sin(angle)*10 - 6, 5, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(head.x + Math.cos(angle)*10, head.y + Math.sin(angle)*10 + 6, 5, 0, Math.PI*2);
  ctx.fill();
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>