<div class="game slither-container" style="position: relative; overflow: hidden; border-radius: 10px; background: #000;">
  <h2>Slither.io Mini (Singleplayer)</h2>
  <div id="slither-ui">
    Score: <span id="score">0</span>
  </div>
  <canvas id="slither-canvas"></canvas>
  <p class="note" style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); margin: 0; z-index: 5; color: #aaa; font-size: 0.9em; pointer-events: none;">
    Finger/Maus bewegen zum Steuern | Doppeltippen oder Leertaste = Boost
  </p>
</div>

<script>
// Slither.io Mini – eigenständiger Singleplayer (Touch + Maus + Boost)

const canvas = document.getElementById('slither-canvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');

let WIDTH = 800;
let HEIGHT = 600;

function resizeCanvas() {
  const rect = canvas.getBoundingClientRect();
  WIDTH = canvas.width = rect.width;
  HEIGHT = canvas.height = rect.height;
  
  const dpr = window.devicePixelRatio || 1;
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
}

window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', resizeCanvas);
resizeCanvas();

let snake = [];
let angle = 0;
let speed = 2.5;
let boost = false;
let score = 0;

function resetGame() {
  snake = [];
  for (let i = 0; i < 25; i++) {
    snake.push({x: WIDTH/2 - i*5, y: HEIGHT/2});
  }
  score = 0;
  scoreEl.textContent = '0';
  foods = [];
  for (let i = 0; i < 100; i++) spawnFood();
}
resetGame();

let foods = [];
function spawnFood() {
  foods.push({
    x: Math.random() * WIDTH,
    y: Math.random() * HEIGHT,
    color: `hsl(${Math.random()*360}, 85%, 60%)`,
    size: 6 + Math.random()*8
  });
}

let pointer = {x: WIDTH/2, y: HEIGHT/2};

function updatePointer(e) {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  pointer.x = clientX - rect.left;
  pointer.y = clientY - rect.top;
}

canvas.addEventListener('mousemove', updatePointer);
canvas.addEventListener('touchmove', updatePointer);
canvas.addEventListener('touchstart', updatePointer);

// Boost: Leertaste oder Doppeltipp
window.addEventListener('keydown', e => {
  if (e.code === 'Space') {
    e.preventDefault();
    boost = true;
  }
});
window.addEventListener('keyup', e => {
  if (e.code === 'Space') boost = false;
});

// Doppeltipp für Touch-Boost
let lastTap = 0;
canvas.addEventListener('touchend', e => {
  const now = Date.now();
  if (now - lastTap < 300) {
    boost = !boost;
  }
  lastTap = now;
});

function update() {
  if (snake.length === 0) return;

  const dx = pointer.x - snake[0].x;
  const dy = pointer.y - snake[0].y;
  angle = Math.atan2(dy, dx);

  let currentSpeed = boost ? speed * 2.2 : speed;
  const head = {
    x: snake[0].x + Math.cos(angle) * currentSpeed,
    y: snake[0].y + Math.sin(angle) * currentSpeed
  };

  // Selbstkollision (ab gewisser Länge)
  if (snake.length > 40) {
    for (let i = 20; i < snake.length; i += 10) {
      if (Math.hypot(head.x - snake[i].x, head.y - snake[i].y) < 18) {
        alert("Game Over! Score: " + score);
        resetGame();
        return;
      }
    }
  }

  snake.unshift(head);

  // Essen aufsammeln
  for (let i = foods.length - 1; i >= 0; i--) {
    const f = foods[i];
    if (Math.hypot(head.x - f.x, head.y - f.y) < f.size + 14) {
      foods.splice(i, 1);
      score += 1;
      scoreEl.textContent = score;
      snake.push({...snake[snake.length-1]});
      spawnFood();
    }
  }

  // Optional: Schrumpfen wenn nicht geboostet
  if (!boost && snake.length > 50 + score) {
    snake.pop();
  }
}

function draw() {
  ctx.fillStyle = '#0a0f1a';
  ctx.fillRect(0, 0, WIDTH, HEIGHT);

  // Gitter-Hintergrund
  ctx.strokeStyle = 'rgba(80,100,220,0.07)';
  ctx.lineWidth = 1;
  for (let x = 0; x < WIDTH; x += 50) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, HEIGHT); ctx.stroke();
  }
  for (let y = 0; y < HEIGHT; y += 50) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(WIDTH, y); ctx.stroke();
  }

  // Essen (Kügelchen)
  foods.forEach(f => {
    ctx.fillStyle = f.color;
    ctx.beginPath();
    ctx.arc(f.x, f.y, f.size, 0, Math.PI*2);
    ctx.fill();
  });

  // Schlange zeichnen
  if (snake.length < 2) return;
  ctx.lineWidth = 28;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  for (let i = 0; i < snake.length - 1; i++) {
    const t = i / (snake.length - 1);
    ctx.strokeStyle = `hsl(${ (t*200 + 180) % 360 }, 95%, 55%)`;
    ctx.beginPath();
    ctx.moveTo(snake[i].x, snake[i].y);
    ctx.lineTo(snake[i+1].x, snake[i+1].y);
    ctx.stroke();
  }

  // Augen am Kopf
  const head = snake[0];
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(head.x + Math.cos(angle)*12, head.y + Math.sin(angle)*12 - 8, 6, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(head.x + Math.cos(angle)*12, head.y + Math.sin(angle)*12 + 8, 6, 0, Math.PI*2);
  ctx.fill();
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

// Starte Loop (mit kleiner Verzögerung falls Canvas noch nicht bereit)
if (WIDTH > 10 && HEIGHT > 10) {
  gameLoop();
} else {
  setTimeout(gameLoop, 300);
}
</script>