<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Slither.io Mini (Singleplayer)</title>
  <style>
    body { margin:0; background:#0d1117; overflow:hidden; }
    canvas { display:block; }
    #ui { position:absolute; top:10px; left:10px; color:white; font-family:Arial; }
  </style>
</head>
<body>
<div id="ui">Score: <span id="score">0</span></div>

<canvas id="c"></canvas>

<script>
// === Mini Slither.io Singleplayer ===
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');

let WIDTH, HEIGHT;
function resize() {
  WIDTH = canvas.width = window.innerWidth;
  HEIGHT = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

let snake = [];
let angle = 0;
let speed = 2.2;
let boost = false;
let score = 0;

// Start-Schlange
for (let i = 0; i < 20; i++) {
  snake.push({x: WIDTH/2 - i*4, y: HEIGHT/2});
}

let foods = [];
function spawnFood() {
  foods.push({
    x: Math.random() * WIDTH,
    y: Math.random() * HEIGHT,
    color: `hsl(${Math.random()*360}, 80%, 60%)`,
    size: 8 + Math.random()*6
  });
}
for (let i = 0; i < 80; i++) spawnFood();

let mouse = {x: WIDTH/2, y: HEIGHT/2};
canvas.addEventListener('mousemove', e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
});
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  mouse.x = e.touches[0].clientX;
  mouse.y = e.touches[0].clientY;
});

window.addEventListener('keydown', e => { if (e.code === 'Space') boost = true; });
window.addEventListener('keyup',   e => { if (e.code === 'Space') boost = false; });

function update() {
  // Richtung zur Maus berechnen
  const dx = mouse.x - snake[0].x;
  const dy = mouse.y - snake[0].y;
  angle = Math.atan2(dy, dx);

  // Bewegung
  let currentSpeed = boost ? speed * 1.8 : speed;
  const head = {
    x: snake[0].x + Math.cos(angle) * currentSpeed,
    y: snake[0].y + Math.sin(angle) * currentSpeed
  };

  // Selbstkollision (einfach ab L채nge 30)
  if (snake.length > 30) {
    for (let i = 10; i < snake.length; i += 8) {
      const dist = Math.hypot(head.x - snake[i].x, head.y - snake[i].y);
      if (dist < 15) {
        alert("Game Over! Score: " + score);
        snake = [{x: WIDTH/2, y: HEIGHT/2}];
        score = 0;
        scoreEl.textContent = 0;
        return;
      }
    }
  }

  snake.unshift(head);

  // Essen essen
  for (let i = foods.length - 1; i >= 0; i--) {
    const f = foods[i];
    const dist = Math.hypot(head.x - f.x, head.y - f.y);
    if (dist < f.size + 12) {
      foods.splice(i, 1);
      score += 1;
      scoreEl.textContent = score;
      snake.push({...snake[snake.length-1]}); // w채chst
      spawnFood();
    }
  }

  // Schlange k체rzen (damit sie nicht endlos w채chst)
  if (!boost && snake.length > 40 + score) {
    snake.pop();
  }
}

function draw() {
  ctx.fillStyle = '#0a0f1a';
  ctx.fillRect(0, 0, WIDTH, HEIGHT);

  // Gitter (optisch nett)
  ctx.strokeStyle = 'rgba(100,120,255,0.08)';
  ctx.lineWidth = 1;
  for (let x = 0; x < WIDTH; x += 40) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, HEIGHT); ctx.stroke();
  }
  for (let y = 0; y < HEIGHT; y += 40) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(WIDTH, y); ctx.stroke();
  }

  // Essen
  foods.forEach(f => {
    ctx.fillStyle = f.color;
    ctx.beginPath();
    ctx.arc(f.x, f.y, f.size, 0, Math.PI*2);
    ctx.fill();
  });

  // Schlange zeichnen (glatt mit Farbverlauf)
  if (snake.length < 2) return;
  ctx.lineWidth = 24;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  for (let i = 0; i < snake.length - 1; i++) {
    const t = i / (snake.length - 1);
    ctx.strokeStyle = `hsl(${t*120 + 180}, 90%, 55%)`;
    ctx.beginPath();
    ctx.moveTo(snake[i].x, snake[i].y);
    ctx.lineTo(snake[i+1].x, snake[i+1].y);
    ctx.stroke();
  }

  // Kopf (Augen)
  const head = snake[0];
  ctx.fillStyle = 'white';
  ctx.beginPath(); ctx.arc(head.x + Math.cos(angle)*8, head.y + Math.sin(angle)*8 - 6, 5, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(head.x + Math.cos(angle)*8, head.y + Math.sin(angle)*8 + 6, 5, 0, Math.PI*2); ctx.fill();
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>